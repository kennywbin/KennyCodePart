
%装饰者和被装饰者对象有相同的超类型。% 必须是一种类型。
可以用一个或多个装饰者包装一个对象。
既然装饰者和被装饰者有相同的超类型，所有在任何需要原始对象（被 包装的）的场合，可以用装饰过的对象替代。
%装饰者可以在所委托被装饰者的行为之前/或之后，加上自己的行为，以达到特定的目的。%（关键点）
对象可以在任何时候被装饰，所以可以在运行时动态地，不限量的用你喜欢的装饰者来装饰对象。

装饰者模式：动态的讲责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

每个组件都可以单独使用，或者被装饰者包起来使用。

Component 每个装饰者都有一个（包装一个）组件，装饰者有一个实例变量以保存某个Component的饮用。

Decorator 装饰者共同实现的接口也可以是抽象类。

ConcreteComponent 将要动态加上新行为的对象，它扩展自Component。

实例：ConcreteDecorator 是实现接口的实例，可以记录所装饰的事物（装饰者包着的Component）。  可以扩展Compnent的状态。

装饰者可以加上新的方法，新行为是通过在旧行为前或后做一些计算来添加的。

可以利用继承达到“类型匹配”，而不是利用继承获得“行为”。

如果依赖继承，类的行为只能在编译时静态决定。行为如果不是来自超类，就是子类覆盖后的。反之，利用组合，可以把装饰者混合着用。而且是在“运行时”。



